#!/usr/bin/env bash

# WOOOOOOOOOOOOOOOOOOOOOOOOOOOO
# VIM TIME

version="bim-indev"
message="welcome to bim"

declare -a buffer
declare -i line col base pad
declare file version message
line=1
col=0
base=1
# adjustable padding. will require additional tweaks to drawing to work properly.
pad=6
unsaved_changes=0
bind 'set disable-completion on' 2>/dev/null
shopt -s checkwinsize; (:)
trap refresh WINCH ALRM
trap cleanup EXIT INT HUP USR1

split() {
   # Usage: split "string" "delimiter"
   # thanks dylan araps :)
   IFS=$'\n' read -d "" -ra arr <<< "${1//$2/$'\n'}"
}

bimrc() {
    # check for rc in various locations
    if [ "$BIMRC" ]; then
        source "$BIMRC" &&
            message="rc loaded from \$BIMRC"
    elif [ -e "$XDG_CONFIG_HOME/bim/bimrc" ]; then
        source "$XDG_CONFIG_HOME/bim/bimrc" &&
            message="rc loaded from \$XDG_CONFIG_HOME"
    elif [ -e "$HOME/.bimrc" ]; then
        source "$HOME/.bimrc" &&
            message="rc loaded from \$HOME"
    elif [ -e "./bimrc" ]; then
        source "./bimrc" &&
            message="rc loaded from current directory"
    fi

    # check if a keymap is provided
    # if not, set defaults
    if [ ! "$(type -t keybinds)" = "function" ]; then
        keybinds() {
            case "${key}" in
            
                # motions
                h) bim_left 1;;
                k) bim_up 1;;
                j) bim_down 1;;
                l) bim_right 1;;
                K) bim_up $((LINES - 4));;
                J) bim_down $((LINES - 4));;
                g) bim_bof;;
                G) bim_eof;;
                t) cursor show
                   bim_goto "$(misc_prompt "goto: ")"
                   cursor hide
                   ;;
                
                # editing
                a|i) bim_edit;;
                I) bim_prepend;;
                d) bim_delete;;
                c) bim_clear;;
                o) bim_insert;;
                O) bim_backinsert;;
                n) bim_blank 1; bim_down 1;;
                N) bim_backblank 1;;
                y) bim_yank;;
                p) bim_paste; bim_down 1;;
            
                # misc
                :) bim_prompt;;
                z) bim_center;;
            
            esac
        }
    fi
}

startup() {
    cursor hide
    cursor spos
    cursor nowrap
    cursor block
}

cleanup() {
    cursor show
    cursor rpos
    cursor goto $LINES 0
    cursor wrap
    cursor block
    exit 0
}

cursor() {
    case "$1" in
    save) printf "\e[?47h";;
    load) printf "\e[?47l";;
    spos) printf "\e7";;
    rpos) printf "\e8\e[B";;
    # hide) printf "\e[?25l";;
    # TEMPORARY, I should go in and remove all cursor hides for this branch.
    hide) true;;
    show) printf "\e[?25h";;
    goto) printf "\e[%s;%sf" "$2" "$3";;
    wrap) printf "\e[?7h";;
    nowrap) printf "\e[?7l";;
    beam) printf "\e[5 q";;
    block) printf "\e[1 q";;
    underline) printf "\e[3 q";;
    esac
}

refresh() {
    clear
    # draw the buffer
    for ((i=base; i-base < LINES-2; i++)); do
        ((i !=  line))        && printf "\e[93m"     || printf "\e[31;1m"
        ((i > ${#buffer[@]})) && printf "   ~\e[m\n" || printf "%4s\e[m %s\n" "$i" "${buffer[i]}"
    done
    # draw message or status bar if no message
    if [ "$message" ]; then
        printf "\e[32;1m%s\e[m\n" "$message"
    else
        printf "\e[36;1m%s [%s] %s/%s {%sx%s}\e[m\n" \
            "$version" "${file}" "$line" "${#buffer[@]}" "$LINES" "$COLUMNS"
    fi
    # temporary queue for debugging x axis
    # breaks the cmd line but fuck you
    # printf "\e[%s;%sf%s" "$line" "$((col+pad))" "#"
    cursor goto "$line" "$((col+pad))"
}

bim_read() {
    if [ "$1" ]; then
        file="$1"
    else
        message="expected argument [FILE]"
        return 1
    fi

    if [ -e "$file" ];then
        mapfile -t -O 1 buffer <"$file"
        message="Read ${#buffer[@]} lines from '$file'"
    else
        message="new file '$file'"
    fi

    [ ${#buffer[@]} -ne 0 ] && line=1
}

bim_write() {
    if [ "$1" ]; then
        myfile="$1"
    elif [ "$file" ]; then
        myfile="$file"
    else
        message="no file to write."
        return 1
    fi
    : >"$myfile"
    for wline in "${buffer[@]}"; do echo "$wline" >> "$myfile"; done
    message="Wrote ${#buffer[@]} lines to '$myfile'"   
    unsaved_changes=0
}

bim_up() {
    [ "$1" ] && num="$1" || num=1
    for ((i=0;i<$num;i++)); do
        ((line > 1))    && ((line--))
    done
}

bim_down() {
    [ "$1" ] && num="$1" || num=1
    for ((i=0;i<$num;i++)); do
        ((line < ${#buffer[@]})) && ((line++))
    done
}

bim_left() {
    ((col > 0)) && ((col--))
}

bim_right() {
    ((col++))
}

bim_fstrong() {
    # find next char after space
    true
}

bim_bstrong() {
    # find prev char after space
    true
}

bim_delete() {
    lineyank="${buffer[line]}"
    buffer=([0]="" "${buffer[@]:1:line-1}" "${buffer[@]:line+1}")
    unset "buffer[0]"
    ((line > ${#buffer[@]})) && ((line--))
    message="line cut."
    unsaved_changes=1
}

bim_insert() {
    buffer=([0]="" "${buffer[@]:1:line}" "" "${buffer[@]:line+1}")
    unset "buffer[0]"
    ((line++))
    # check if autotab is on and if the tab block we're extending starts with spaces
    if [ $autotab = 1 ] && [ "${buffer[line-1]::1}" = " " ]; then
        # wacky code to get the tab size of the last line
        local lasttab="${buffer[line-1]%${buffer[line-1]##* }}"
        # put in that same tab length to what we're going to edit
        buffer[line]="$lasttab"
    fi
    # I have no clue why this has to be "-4" here
    ((line > base+LINES-4))  && ((base++))
    bim_edit
}

bim_backinsert() {
    buffer=([0]="" "${buffer[@]:1:line-1}" "" "${buffer[@]:line}")
    unset "buffer[0]"
    # same code as 'bim_insert'
    if [ $autotab = 1 ] && [ "${buffer[line+1]::1}" = " " ]; then
        local lasttab="${buffer[line+1]%${buffer[line+1]##* }}"
        buffer[line]="$lasttab"
    fi
    bim_edit
}

bim_blank() {
    [ "$1" ] && num="$1" || num=1
    for ((i=0;i<$num;i++)); do
        buffer=([0]="" "${buffer[@]:1:line}" "" "${buffer[@]:line+1}")
        unset "buffer[0]"
    done
}

bim_backblank() {
    [ "$1" ] && num="$1" || num=1
    for ((i=0;i<$num;i++)); do
        buffer=([0]="" "${buffer[@]:1:line-1}" "" "${buffer[@]:line}")
        unset "buffer[0]"
    done
}

bim_yank() {
    lineyank="${buffer[line]}"
    message="line yanked."
}

bim_paste() {
    buffer=([0]="" "${buffer[@]:1:line}" "$lineyank" "${buffer[@]:line+1}")
    unset "buffer[0]"
}

bim_clear() {
    ((line == 0)) && return
    cursor goto $((line-base + 2)) $pad
    buffer[line]=""
    unsaved_changes=1
}

# insert mode
# my new robust replacement for 'read' that goes character by character
bimput() { # <var> [starting string]
    # starting text of line
    local buf="$2"
    local ch=""
    cursor beam
    cursor show
    while true; do
        IFS='' read -s -n1 ch
        case "$ch" in
            "")
                bimputstatus="esc"
                break
                ;;
            # read -n1 seems to interpret ENTER as nothing
            "")
                bimputstatus="enter"
                break
                ;;
            # vscode is unable do display a backspace
            # but there is one between these quotes
            "")
                if [ "$buf" ]; then
                    buf="${buf%?}"
                    printf "\b \b"
                else
                    bimputstatus="backline"
                    break
                fi
                ;;
            "	")
                buf="${buf}${shiftwidth:="  "}"
                echo -n "${shiftwidth}"
                ;;
            *)
                buf="${buf}${ch}"
                printf "$ch"
                ;;
        esac
    done
    eval "${1}=\${buf}"
    cursor hide
    cursor block
}

bim_edit() {
    # refresh, as 'read' will freeze drawing
    refresh
    # make a line in an empty buffer
    ((line == 0)) && buffer[1]="" && line=1 && refresh
    # print '--INSERT--' at the bottom
    cursor goto $LINES
    printf "\e[32m%s\e[m" "--INSERT--"
    # do the actual thing
    cursor goto $((line-base + 1)) $((pad + ${#buffer[line]}))
    bimput "buffer[line]" "${buffer[line]}"
    case "$bimputstatus" in
        "enter")
            # nice and simple
            bim_insert
            ;;
        "backline")
            # delete line
            buffer=([0]="" "${buffer[@]:1:line-1}" "${buffer[@]:line+1}")
            unset "buffer[0]"
            # go back a line and edit
            ((line--))
            bim_edit
            ;;
    esac
    unsaved_changes=1
}

bim_prepend() {
    # refresh, as 'read' will freeze drawing
    refresh
    # make a line in an empty buffer
    ((line == 0)) && buffer[1]="" && line=1 && refresh
    # print '--INSERT--' at the bottom
    cursor goto $LINES
    printf "\e[32m%s\e[m" "--PREPEND--"
    # do the actual thing
    cursor goto $((line-base + 2)) 4
    printf "^~"
    cursor underline
    cursor show
    read -re
    cursor hide
    cursor block
    # write $REPLY + what was already there
    buffer[line]="${REPLY}${buffer[line]}"
    unsaved_changes=1
}

bim_prompt() {
    bind 'set disable-completion off' 2>/dev/null
    cursor goto "$LINES" "0"
    read -rep ":" choice
    bind 'set disable-completion on' 2>/dev/null

    # run command and wait
    if [ "${choice::1}" = "!" ]; then
        eval "${choice##!}"
        cursor hide
        printf "\e[31mpress any key to continue."
        read -N1 -r
    # read command output
    elif [ "${choice::3}" = "r !" ]; then
        eval "output=\"\$(${choice##r !})\""
        split "$output" $'\n'
        bim_blank ${#arr[@]}
        i=0
        while [ $i -lt ${#arr[@]} ]; do
            buffer[line+i+1]="${arr[i]}"
            unset "buffer[0]"
            ((i++))
        done
        cursor hide
        unsaved_changes=1
    # simply run command
    else
        eval "$choice"
        succ=$?
        if [ ! "$(type -t ${choice%% *})" = "function" ]; then
            message="finished with exit code $succ"
        fi
        cursor hide
    fi
    # cursor must be hidden in each case individually.
}

misc_prompt() {
    # cursor must be shown (and now placed, in the axis branch) externally
    # as to not pass escape sequences into functions
    [ "$1" ] || return 1
    bind 'set disable-completion off' 2>/dev/null
    read -rep "$1"
    bind 'set disable-completion on' 2>/dev/null

    printf '%s' "$REPLY"
}

quit() {
    if [ "$unsaved_changes" = 0 ]; then
        exit 0
    else
        message="unsaved changes. force quit with \":qq\""
    fi
}

bim_bof() {
	[ ${#buffer[@]} = 0 ] && return 1
    line=1
}

bim_eof() {
    line=${#buffer[@]}
}

bim_goto() {
    [ "$1" ] || return 1
    [ ${#buffer[@]} -ge $1 ] && line=$1
}

bim_center() {
    (( base=line-((LINES-3)/2) ))
    [ $base -lt 1 ] && base=1
}

# functions that are really just aliases
# and shortcuts for the command line

w() {
    bim_write "$@"
}

q() {
    quit
}

qq() {
    exit 0
}

wq() {
    w "$@" && q
}

e() {
    bim_read "$@"
}


keyboard_loop () {
    startup
    if [ "$1" ]; then
        bim_read "$1"
    else
        buffer[1]="sample text"
    fi
    refresh

    while true; do
        read -rsN1 key
        message=""

        # iteration (only 2 digit numbers)
        # cancel with ESC
        case $key in
            1|2|3|4|5|6|7|8|9)
                digit1="$key"
                printf '%d' "$key"
                read -rsN1 key
                case $key in
                    1|2|3|4|5|6|7|8|9|0)
                        digit2="$key"
                        printf '%d' "$key"
                        read -rsN1 key
                        ;;
                    "")
                        digit1="1"
                        digit2=""
                        ;;
                    *)
                        digit2=""
                        ;;
                esac
                ;;
            "")
                digit1="1"
                digit2=""
                ;;
            *)
                digit1="1"
                digit2=""
                ;;
        esac

        # compute keys from rc or defaults
        # reiterate if applicable
        kbj="${digit1}${digit2}"
        for ((kbinc=0; kbinc < kbj; kbinc++)); do
            keybinds
        done

        # universal scrolling system
        if [ $base -gt $line ]; then
            [ $base = 1 ] || base=$line
        elif (( base+LINES-3 < line )); then
            ((base=line-LINES+3))
        fi

        # axis branch: universal bounding for x axis
        if [ $col -ge ${#buffer[line]} ]; then
            col=${#buffer[line]}
        fi

        # refresh the UI
        refresh
    done
    clear
}

usage () {
cat <<EOF
bim: bash vim

usage: ${0##*/} [ options | file ]

options:
    -h|--help : print this help message
    -k|--keys : print a basic usage document
    -d|--rcdoc: print rc info and general scripting info
    -c|--rc   : test for rc file
EOF
}

keys () {
cat <<EOF
### bim defaults ###

# navigation
  j - move down  (:bim_down [LINES])
  k - page up    (:bim_up [LINES])
  J - page down
  K - page up
  g - first line (:bim_bof)
  G - last line  (:bim_eof)
  t - go to line (:bim_goto [LINE])

# editing
  a - append to line  (:bim_edit)
  I - prepend to line (:bim_prepend)
  d - delete line     (:bim_delete)
  c - clear line      (:bim_clear)
  y - yank line       (:bim_yank)
  p - paste line      (:bim_paste)
  n - create line below (:bim_blank [LINES])
  N - create line above (:bim_backblank [LINES])
  o - create line below and edit (:bim_insert)
  O - create line above and edit (:bim_backinsert)

# commands
# NOTE: the command line is for both editor and shell commands.
   : - open command line
  :w [FILE] - write to current or given file
  :q - quit
 :qq - force quit
 :wq - write and quit
  :e [FILE] - open file
  :![COMMAND] - pause to view the output of a command
:r ![COMMAND] - read output of a command

### scripting ###

all inputs can also be typed as commands.
this allows for scripting.
run bim in the repository and type:
:source example.bash
and see what happens!
for more information on extending bim, run "bim -d"
EOF
}

rcdoc() {
cat <<EOF
this doc is printed when "-d" is passed or no rc is found.

### BIMRC ###

the rc is read from these locations in this order:
\$BIMRC
\$XDG_CONFIG_HOME/bim/bimrc
\$HOME/.bimrc
./bimrc
it is recommended to look at or even copy the example rc.
it contains the default keybinds and some silly functions as examples.
the rc file is simply a series of shell function definitions.
these functions can be typed as commands or bound to keys.
care should be taken to avoid naming conflicts.

### KEYBINDS ###

'keybinds()' is a special function that is integral to the main loop.
if it is not defined in the rc, defaults will be used.

# example
keybinds() {
    case "\${key}" in
        a) my_firstfunction [args];;
        b) my_otherfunction [args];;
        c) my_thirdfunction [args];;
    esac
}

### SCRIPTING ###

functions in your rc can be simple lists of actions like so:

# example
add_three_lines() {
    bim_blank
    bim_blank
    bim_blank
}

however, to actually get some value out of scripting,
you probably want to manipulate the editor on a deeper level.
here are some variables you must be aware of.

\$line        # the selected line
\${buffer[@]} # the array that stores the buffer
\$base        # the first line visible in the window
\$file        # file that 'bim_write' writes to if not given an argument
\$unsaved_changes    # whether unsaved changes are present

# silly, basic examples
# for some real, useful functions, see the example bimrc.
goto_seven() {
    # set active line to 7 if it exists
    [ \${#buffer[@]} -ge 7 ] && line=7
}
set_poggers() {
    # exit if line is 0 (no lines in buffer)
    [ \$line = 0 ] && return 1
    # set the current line's contents
    buffer[line]="poggers!"
}
EOF
}

main() {
    case $1 in
        -h|--help) trap : EXIT; usage;;
        -k|--keys) trap : EXIT; keys;;
        -c|--rc)
            trap : EXIT
            bimrc
            if [ "$message" = "welcome to bim" ]; then
                rcdoc
            else
                echo "testing: $message successfully."
            fi
            ;;
        -d|--rcdoc) trap : EXIT; rcdoc;;
        *) bimrc; keyboard_loop "$1";;
    esac
}

main "$@"