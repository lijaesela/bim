#!/usr/bin/env bash

### urgent

# read commands
# insert from beginning

### maybe?

# truly iron out multiline inserts

line=0
base=1
version="alpha"
message="welcome to bim"
unsaved_changes=0

declare -a buffer
declare -i line base
declare file version message
bind 'set disable-completion on' 2>/dev/null
shopt -s checkwinsize; (:)
trap refresh WINCH ALRM
trap cleanup EXIT INT HUP USR1

split() {
   # Usage: split "string" "delimiter"
   # thanks dylan araps :)
   IFS=$'\n' read -d "" -ra arr <<< "${1//$2/$'\n'}"
}

bimrc() {
    # check for rc in various locations
    if [ "$BIMRC" ]; then
        source "$BIMRC" &&
            message="rc loaded from \$BIMRC"
    elif [ -e "$XDG_CONFIG_HOME/bim/bimrc" ]; then
        source "$XDG_CONFIG_HOME/bim/bimrc" &&
            message="rc loaded from \$XDG_CONFIG_HOME"
    elif [ -e "$HOME/.bimrc" ]; then
        source "$HOME/.bimrc" &&
            message="rc loaded from \$HOME"
    elif [ -e "./bimrc" ]; then
        source "./bimrc" &&
            message="rc loaded from current directory"
    fi

    # check if a keymap is provided
    # if not, set defaults
    if [ ! "$(type -t keybinds)" = "function" ]; then
        keybinds() {
            case "${key}" in
            
                # motions
                k) bim_up 1;;
                j) bim_down 1;;
                K) bim_up $((LINES - 4));;
                J) bim_down $((LINES - 4));;
                g) bim_bof;;
                G) bim_eof;;
                
                # editing
                a) bim_edit;;
                I) bim_prepend;;
                d) bim_delete;;
                c) bim_clear;;
                o) bim_insert;;
                O) bim_backinsert;;
                n) bim_blank;;
                N) bim_backblank;;
                y) bim_yank;;
                p) bim_paste;;
            
                # misc
                :) bim_prompt;;
            
            esac
        }
    fi
}

startup() {
    cursor hide
    cursor spos
    cursor nowrap
    cursor block
}

cleanup() {
    cursor show
    cursor rpos
    cursor goto $LINES 0
    cursor wrap
    exit 0
}

cursor() {
    case "$1" in
    save) printf "\e[?47h";;
    load) printf "\e[?47l";;
    spos) printf "\e7";;
    rpos) printf "\e8\e[B";;
    hide) printf "\e[?25l";;
    show) printf "\e[?25h";;
    goto) printf "\e[%s;%sf" "$2" "$3";;
    wrap) printf "\e[?7h";;
    nowrap) printf "\e[?7l";;
    beam) printf "\e[5 q";;
    block) printf "\e[1 q";;
    esac
}

refresh() {
    clear
    #printf "\e[36m %s (%s Lines) %s %sx%s %s \e[m\n" \
        #"$file" "${#buffer[@]}" "$version" "$LINES" "$COLUMNS" "$base"
    for ((i=base; i-base < LINES-2; i++)); do
        ((i !=  line))        && printf "\e[93m"     || printf "\e[31;1m"
        ((i > ${#buffer[@]})) && printf "   ~\e[m\n" || printf "%4s\e[m %s\n" "$i" "${buffer[i]}"
    done
    if [ "$message" ]; then
        printf "\e[32;1m%s\e[m\n" "$message"
    else
        printf "\e[36;1m%s (%s Lines) %s (%sx%s) %s \e[m\n" \
            "$file" "${#buffer[@]}" "$version" "$LINES" "$COLUMNS" "$base"
    fi
}

bim_read() {
    if [ "$1" ]; then
        file="$1"
    else
        message="expected argument [FILE]"
        return 1
    fi

    if [ -e "$file" ];then
        mapfile -t -O 1 buffer <"$file"
        message="Read ${#buffer[@]} lines from '$file'"
    else
        message="new file '$file'"
    fi

    [ ${#buffer[@]} -ne 0 ] && line=1
}

bim_write() {
    if [ "$1" ]; then
        myfile="$1"
    elif [ "$file" ]; then
        myfile="$file"
    else
        message="no file to write."
        return 1
    fi
    : >"$myfile"
    for wline in "${buffer[@]}"; do echo "$wline" >> "$myfile"; done
    message="Wrote ${#buffer[@]} lines to '$myfile'"   
    unsaved_changes=0
}

bim_up() {
    for ((i=0;i<$1;i++)); do
        ((line > 1))    && ((line--))
        ((line < base)) && ((base--))
        ((base <= 0))   && base=1
    done
}

bim_down() {
    for ((i=0;i<$1;i++)); do
        ((line < ${#buffer[@]})) && ((line++))
        ((line > base+LINES-3))  && ((base++))
    done
}

bim_delete() {
    lineyank="${buffer[line]}"
    buffer=([0]="" "${buffer[@]:1:line-1}" "${buffer[@]:line+1}")
    unset "buffer[0]"
    ((line > ${#buffer[@]})) && ((line--))
    message="line cut."
    unsaved_changes=1
}

bim_insert() {
    buffer=([0]="" "${buffer[@]:1:line}" "" "${buffer[@]:line+1}")
    unset "buffer[0]"
    ((line++))
    # I have no clue why this has to be "-4" here
    ((line > base+LINES-4))  && ((base++))
    refresh
    bim_edit
}

bim_backinsert() {
    buffer=([0]="" "${buffer[@]:1:line-1}" "" "${buffer[@]:line}")
    unset "buffer[0]"
    refresh
    bim_edit
}

bim_blank() {
    buffer=([0]="" "${buffer[@]:1:line}" "" "${buffer[@]:line+1}")
    unset "buffer[0]"
    ((line++))
    ((line > base+LINES-3))  && ((base++))
}

bim_backblank() {
    buffer=([0]="" "${buffer[@]:1:line-1}" "" "${buffer[@]:line}")
    unset "buffer[0]"
    ((line++))
    ((line > base+LINES-3))  && ((base++))
}

bim_yank() {
    lineyank="${buffer[line]}"
    message="line yanked."
}

bim_paste() {
    buffer=([0]="" "${buffer[@]:1:line}" "$lineyank" "${buffer[@]:line+1}")
    unset "buffer[0]"
    ((line++))
    ((line > base+LINES-3))  && ((base++))
}

bim_clear() {
    ((line == 0)) && return
    cursor goto $((line-base + 2)) 6
    buffer[line]=""
    unsaved_changes=1
}

bim_edit() {
    # refresh, as 'read' will freeze drawing
    refresh
    # make a line in an empty buffer
    ((line == 0)) && buffer[1]="" && line=1 && refresh
    # print '--INSERT--' at the bottom
    cursor goto $LINES
    printf "\e[32m%s\e[m" "--INSERT--"
    # do the actual thing
    cursor goto $((line-base + 1)) 6
    cursor beam
    cursor show
    read -d $'\e' -rei "${buffer[line]}"
    cursor hide
    cursor block
    # support for multiline inserts
    if [[ "$REPLY" == *""* ]]; then
        # do some complicated shit
        split "$REPLY" ""
        buffer=([0]="" "${buffer[@]:1:line-1}" "${buffer[@]:line+1}")
        unset "buffer[0]"
        i=0
        while [ $i -lt ${#arr[@]} ]; do
            buffer=([0]="" "${buffer[@]:1:line+i-1}" "${arr[$i]}" "${buffer[@]:line+i}")
            unset "buffer[0]"
            ((i++))
        done
    else
        # just do a plain ol' write to the array if ENTER isn't hit
        buffer[line]="$REPLY"
    fi
    unsaved_changes=1
}

bim_prepend() {
    # refresh, as 'read' will freeze drawing
    refresh
    # make a line in an empty buffer
    ((line == 0)) && buffer[1]="" && line=1 && refresh
    # print '--INSERT--' at the bottom
    cursor goto $LINES
    printf "\e[32m%s\e[m" "--PREPEND--"
    # do the actual thing
    cursor goto $((line-base + 2)) 4
    printf "^~"
    cursor beam
    cursor show
    read -re
    cursor hide
    cursor block
    # write $REPLY + what was already there
    buffer[line]="${REPLY}${buffer[line]}"
    unsaved_changes=1
}

bim_prompt() {
    bind 'set disable-completion off' 2>/dev/null
    cursor show
    read -rep ":" choice
    bind 'set disable-completion on' 2>/dev/null

    if [ "${choice::1}" = "!" ]; then
        eval "${choice##!}"
        cursor hide
        printf "\e[31mpress any key to continue."
        read -N1 -r
    #elif [ "${choice::3}" = "r !" ]; then
    else
        eval "$choice"
        succ=$?
        if [ ! "$(type -t ${choice%% *})" = "function" ]; then
            message="finished with exit code $succ"
        fi
        cursor hide
    fi
}

misc_prompt() {
    # cursor must be shown externally
    # as to not pass escape sequences into functions
    [ "$1" ] || return 1
    bind 'set disable-completion off' 2>/dev/null
    read -rep "$1"
    bind 'set disable-completion on' 2>/dev/null

    printf '%s' "$REPLY"
}

quit() {
    if [ "$unsaved_changes" = 0 ]; then
        exit 0
    else
        message="unsaved changes. force quit with \":qq\""
    fi
}

bim_bof() {
	[ ${#buffer[@]} = 0 ] && return 1
    line=1
}

bim_eof() {
    line=${#buffer[@]}
}

# functions that are really just aliases
# and shortcuts for the command line

w() {
    bim_write "$@"
}

q() {
    quit
}

qq() {
    exit 0
}

wq() {
    w "$@" && q
}

e() {
    bim_read "$@"
}


keyboard_loop () {
    startup
    [ "$1" ] && bim_read "$1"
    refresh

    while true; do
        read -rsN1 key
        message=""

        # compute keys from rc or defaults
        keybinds

        # Refresh the UI
        refresh
    done
    clear
}

usage () {
cat <<EOF
bim: bash vim

usage: ${0##*/} [ options | file ]

options:
    -h|--help:  print this help message
    -k|--keys:  print a basic usage document
    -d|--rcdoc: print rc info and general scripting info
    -c|--rc:    test for rc file

if no file is given, default is bim.txt
EOF
}

keys () {
cat <<EOF
### bim defaults ###

# navigation
j,k - move up or down
J,K - page up and down

# editing
  a - append to line  (:bim_edit)
  I - prepend to line (:bim_prepend)
  d - delete line     (:bim_delete)
  c - clear line      (:bim_clear)
  y - yank line       (:bim_yank)
  p - paste line      (:bim_paste)
  n - create line below (:bim_blank)
  N - create line above (:bim_backblank)
  o - create line below and edit (:bim_insert)
  O - create line above and edit (:bim_backinsert)

# commands
  : - open command line
 :w [FILE] - write to current or given file
 :q - quit
:qq - force quit
:wq - write and quit
 :e [FILE] - open file
 :! [COMMAND] - pause to view the output of a command

note: you CAN run shell commands.
just run them. no "!" required :)

### scripting ###

all inputs can also be typed as commands.
this allows for scripting.
run bim in the repository and type:
:source example.bash
and see what happens!
for more information on extending bim, run "bim -d"
EOF
}

rcdoc() {
cat <<EOF
this doc is printed when "-d" is passed or no rc is found.

### BIMRC ###

the rc is read from these locations in this order:
\$BIMRC
\$XDG_CONFIG_HOME/bim/bimrc
\$HOME/.bimrc
it is recommended to look at or even copy the example rc.
it contains the default keybinds and some silly functions as examples.
the rc file is simply a series of shell function definitions.
these functions can be typed as commands or bound to keys.
care should be taken to avoid naming conflicts.

### KEYBINDS ###

'keybinds()' is a special function that is integral to the main loop.
if it is not defined in the rc, defaults will be used.

# example
keybinds() {
    case "\${key}" in
        a) my_firstfunction [args];;
        b) my_otherfunction [args];;
        c) my_thirdfunction [args];;
    esac
}

### SCRIPTING ###

functions in your rc can be simple lists of actions like so:

# example
add_three_lines() {
    bim_blank
    bim_blank
    bim_blank
}

however, to actually get some value out of scripting,
you probably want to manipulate the editor on a deeper level.
here are some variables you must be aware of.

\$line        # the selected line
\${buffer[@]} # the array that stores the buffer
\$base        # the first line visible in the window
\$file        # file that 'bim_write' writes to if not given an argument

# silly, basic examples
# for some real, useful functions, see the example bimrc.
goto_seven() {
    # set active line to 7
    line=7
}
set_poggers() {
    # exit if line is 0 (no line)
    [ \$line = 0 ] && return 1
    # set the current line's contents
    buffer[line]="poggers!"
}
EOF
}

main() {
    case $1 in
        -h|--help) trap : EXIT; usage;;
        -k|--keys) trap : EXIT; keys;;
        -c|--rc)
            trap : EXIT
            bimrc
            if [ "$message" = "welcome to bim" ]; then
                rcdoc
            else
                echo "testing: $message successfully."
            fi
            ;;
        -d|--rcdoc) trap : EXIT; rcdoc;;
        *) bimrc; keyboard_loop "$1";;
    esac
}

main "$@"
